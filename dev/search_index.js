var documenterSearchIndex = {"docs":
[{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"CurrentModule = NLS_Fit","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"using NLS_Fit\nusing DelimitedFiles\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")","category":"page"},{"location":"simple_fit/#Simple-fit","page":"Simple fit","title":"Simple fit","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"You can reproduce the following computation using sandbox/simple_gaussian.jl.","category":"page"},{"location":"simple_fit/#Data-and-model","page":"Simple fit","title":"Data and model","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The first example is a simple Gaussian peak fit. We use the data/simple_gaussian.txt data file. ","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"XY=readdlm(joinpath(dataDir,\"simple_gaussian.txt\")) # hide\nX = XY[:,1] # hide\nY = XY[:,2] # hide\nplot(X,Y, seriestype = :scatter, label = \"raw data\")","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The model is a single Gaussian peak. ","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"model = Gaussian_Peak()","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The model does no embeds its model parameters. So before being able to evaluate model values one must define a parameter vector θ. For Gaussian_Peak, this vector is [h,μ,σ]. It stores the peak height, its center and its shape factor.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"θ_init = Float64[1,10,5]","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We now have everything we need to evaluate model values. This is the role of the eval_y function. This function compute model Y values given its parameter vector θ and the evaluation sites X.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"Y_init = eval_y(model,X,θ_init)\nplot!(X,Y_init, label = \"initial model\")","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We see that the parameter vector θ is not a good guess to fit the peak to the raw data. We will see now how to automatically adjust these parameters using a Levenberg-Marquardt like method.","category":"page"},{"location":"simple_fit/#Model-fitting","page":"Simple fit","title":"Model fitting","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"This package embeds the NLS_Solver.jl package to perform nonlinear least squares regressions. To use it you simply have to add the NLS_Solver prefix. The example below explains this in details.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We want to solve this nonlinear least squares problem:","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"minlimits_theta frac12Y-m(Xtheta)_2^2","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The objective function is created as follows:","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"nls = NLS_ForwardDiff_From_Model2Fit(model,X,Y)","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We now select the solver, here the Levenberg-Marquardt method","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"conf = NLS_Solver.LevenbergMarquardt_Conf()","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"and solve the problem:","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"result = NLS_Solver.solve(nls,θ_init,conf)","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"Note that we have used the NLS_Solver. prefix, without importing again the NLS_Solver.jl package.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"danger: Caveat\nDo not re-import the NLS_Solver.jl package by typing using NLS_Solver.  As NLS_Fit already embeds this package, this may cause versions conflicts. The right way to go is to add a NLS_Solver prefix when you need some of the NLS_Solver.jl package functionalities.","category":"page"},{"location":"simple_fit/#Fit-result","page":"Simple fit","title":"Fit result","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We can check that the solver converged","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"NLS_Solver.converged(result)","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"and plot the fitted model","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"θ_fit = NLS_Solver.solution(result)\nY_fit = eval_y(model,X,θ_fit)\nplot!(X,Y_fit, label = \"fitted model\", linewidth=3)","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"CurrentModule = NLS_Fit","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"using NLS_Fit\nusing DelimitedFiles\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"!!! warning WIP, one must create a mechanism to set μ_i = constant     (instead of imposing const using bound constraints). This would     gain in clarity","category":"page"},{"location":"mapped_parameters/#Mapped-parameters","page":"Mapped parameters","title":"Mapped parameters","text":"","category":"section"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"You can reproduce the following computation by running sandbox/mapped_parameters.jl.","category":"page"},{"location":"mapped_parameters/#Data-and-model","page":"Mapped parameters","title":"Data and model","text":"","category":"section"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"In this example there are 3 Gaussian peaks with different shape factors sigma_1 sigma_2 sigma_3. The goal here is to constrain these shape factors to have an affine dependence with respect to X. ","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"Let us plot the initial data and model.","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"model = Gaussian_Peak() + Gaussian_Peak() + Gaussian_Peak()\n\nθ1 = Float64[1,5,1]\nθ2 = Float64[1,10,1]\nθ3 = Float64[1,20,1]\n\nθ_model = vcat(θ1,θ2,θ3)","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"This parameter vector is:","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"h_1 mu_1 sigma_1 h_2 mu_2 sigma_2 h_3 mu_3 sigma_3","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"XY=readdlm(joinpath(dataDir,\"mapped_parameters.txt\")) # hide\nX = XY[:,1] # hide\nY = XY[:,2] # hide\nplot(X,Y, seriestype = :scatter, label = \"raw data\")\n\nY_model = eval_y(model,X,θ_model)\nplot!(X,Y_model, label = \"initial model\")","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"For the model the three shape factors are constant sigma_i=1. This does not fit well the synthetic data which has been generated with (sigma_1 sigma_2 sigma_3)=(1152).","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"The fit procedure can find the right values for these individual and independent sigma_i, but in practice it is often more robust to constrain these parameters to follow a given (physical) law. In this example we will create a model where the sigma_i follow an affine law:","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"σ(X) = L_A(X) σ_A θ_A + L_B(X) σ_B θ_B ","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"where L_A L_B are the Lagrange basis.","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"A detailed description about this affine function parametrization is given in A model for calibration. Please reread this section if the following two lines make no sense for you.","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"# define a map:  X_A => σ_A,  X_B => σ_B\nmap_pos2sigma = Map_Affine(1.0  => 1.0, 30.0 => 5.0)\n# initial parameter value\nθ_map = ones(NLS_Fit.parameter_size(map_pos2sigma))\nnothing # hide","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"We now create a vector of components mu_1 mu_2 mu_3. This components are the 3 Gaussian peak positions. These positions are used to compute the shape factors sigma_i=sigma(μ_i) using the map_pos2sigma. To write these shape factors at the right emplacements in the θ_model vector we also need the indices of the sigma_1 sigma_2 sigma_3 parameters.","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"σ_indices = [3,6,9]\nref_pos   = [5.0, 10.0, 20.0]\nnothing # hide","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"The indices are found by θ parameter vector inspection:","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"beginarrayrcccccccccl\n  1  2  mathbf3  4  5  mathbf6  7  8  mathbf9   \n  h_1  mu_1  sigma_1  h_2  mu_2  sigma_2  h_3  mu_3  sigma_3   \nendarray","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"We now have all the required information to create the model where the 3 shape factors follow the affine law sigma(X):","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"model_with_σ_law = Model2Fit_Mapped_Parameters(model,map_pos2sigma,σ_indices,ref_pos)\nnothing # hide","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"The new parameter vector θ_model_with_σ_law is build from the initial parameter vector θ_model. We must first remove the parameters associated to sigma_1 sigma_2 sigma_3 (as there are going to be replaced by sigma(mu_1) sigma(mu_2) sigma(mu_3)). We then have to add the map_pos2sigma extra parameters. All these modifications can be performed by:","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"θ_model_with_σ_law = vcat(deleteat!(copy(θ_model),σ_indices),θ_map)","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"This parameter vector is of the form:","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"h_1 mu_1 h_2 mu_2 h_3 mu_3 theta_A theta_B","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"We can easily retrieve the parameters vector θ_model with values induces by the map_pos2sigma transformation:","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"get_model_θ(model_with_σ_law,θ_model_with_σ_law)","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"We see that the model with its initial θ_model_with_σ_law parameter vector overestimate the shape factor sigma_i. This is also visible if we plot the model Y value:","category":"page"},{"location":"mapped_parameters/","page":"Mapped parameters","title":"Mapped parameters","text":"Y_model_with_σ_law = eval_y(model_with_σ_law,X,θ_model_with_σ_law)\nplot!(X,Y_model_with_σ_law, label = \"initial model with constrained σ\")","category":"page"},{"location":"mapped_parameters/#Fit","page":"Mapped parameters","title":"Fit","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"CurrentModule = NLS_Fit","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"using NLS_Fit\nusing DelimitedFiles\nusing LinearAlgebra\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")","category":"page"},{"location":"recalibration/#Peak-fitting-and-recalibration","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"You can reproduce the following computation using sandbox/recalibration.jl.","category":"page"},{"location":"recalibration/#Problem-description-and-data","page":"Peak fitting and recalibration","title":"Problem description and data","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"In this problem one must fit 3 Gaussian peaks at positions 5, 10, 20. However the loaded data (X,Y) presents a miscalibrated X. This miscalibrated X is computed from The \"true\" X as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X = 11 X_texttrue + 02","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The complete process to generate the synthetic data is:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"using DelimitedFiles,Random\nusing NLS_Fit\n\nRandom.seed!(1234)\n\nmodel = Gaussian_Peak() + Gaussian_Peak() + Gaussian_Peak()\nθ1 = Float64[1,5,1]\nθ2 = Float64[1.5,10,2]\nθ3 = Float64[0.75,20,3]\nθ = vcat(θ1,θ2,θ3)\n\nX=Float64[1:0.25:30;]\nn=length(X)\nY=eval_y(model,X,θ) + 0.1*(rand(n) .- 0.5)\n\n@. X = 1.1*X + 0.2 # inverse map is: 0.91 * X - 0.18\n\nrootDir = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")\ndataFile = joinpath(dataDir,\"recalibration.txt\")\nwritedlm(dataFile,hcat(X,Y))\n\n","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"If we plot this, we get:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"XY=readdlm(joinpath(dataDir,\"recalibration.txt\")) # hide\nX = XY[:,1] # hide\nY = XY[:,2] # hide\nplot(X,Y, seriestype = :scatter, label = \"raw data\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can also plot miscalibrated X and the \"true\" one X_texttrue. We only now X, but as we generated artificial data, we know that ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X = 11 X_texttrue + 02","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"which can easily be inverted to give ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X_texttrue = (X - 02)11","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can now plot both X and X_texttrue:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X_true = (X .- 0.2)/1.1\nplot(X_true, seriestype = :scatter, markershape = :xcross, label = \"true X\")\nplot!(X, seriestype = :scatter, label = \"miscalibrated X\")","category":"page"},{"location":"recalibration/#The-model","page":"Peak fitting and recalibration","title":"The model","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The first step is to define an uncalibrated model.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"model = Gaussian_Peak() + Gaussian_Peak() + Gaussian_Peak()\n\nθ1 = Float64[1.0,5,1]\nθ2 = Float64[1.5,10,2]\nθ3 = Float64[0.75,20,3]\nθ_uncalibrated_model = vcat(θ1,θ2,θ3)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"This model is the sum of three Gaussian peaks, its parameter vector θ is","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"theta =  h_1 mu_1 sigma_1 h_2 mu_2 sigma_2 h_3 mu_3 sigma_3","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Even if the centers mu_1 mu_2 mu_3 are corrects, the peaks are miss positioned due to the bad calibration:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Y_uncalibrated_model = eval_y(model,X,θ_uncalibrated_model)\n\nplot(X,Y, seriestype = :scatter, label = \"raw data\")\nplot!(X,Y_uncalibrated_model, label = \"uncalibrated model\")","category":"page"},{"location":"recalibration/#A_model_for_calibration","page":"Peak fitting and recalibration","title":"A model for calibration","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The idea to create a recalibrable model hatm is as follows. We use an initial model m(thetahatX) to create a new one where the spatial variable hatX is transformed X=f_hattheta(hatX):","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"hatm(thetahatthetahatX)=m(thetaX=f_hattheta(hatX))","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"With this approach, the initial model m sees the calibrated X. The calibration map, f_hattheta is parameterized by hattheta. The create calibrable model is defined by a new parameter vector of the form thetahattheta.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"For the current example we will use an affine function for f_hattheta. This function is defined as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"f_hattheta(hatX) = L_A(hatX)X_Ahattheta_A + L_B(hatX)X_Bhattheta_B","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"where L_A L_B are the Lagrange basis, ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"L_A(hatX)=frachatX_B-hatXhatX_B-hatX_A  L_B(hatX)=frachatX-hatX_AhatX_B-hatX_A","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We remark that for hattheta= hattheta_Ahattheta_B=11 the transform f_hattheta is the transform that maps  hatX_A to X_A and hatX_B to X_B. This did not happen by chance.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"note: Note\nWhenever possible we try to use parametrizations such that hattheta=1dots1 has a  special role, like identity transform. This hattheta=1dots1 can be used as parameter  initial value. This is important from a numerical point of view, where it is better to have an  unknown vector theta where all components have the same order of magnitude.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"On the Julia side, the affine transform f_hattheta is declared as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Map_Affine(hat_X_A => X_A, hat_X_B => X_B)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"whereas the shortened version","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Map_Affine(X_A, X_B)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"means","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Map_Affine(X_A => X_A, X_B => X_B)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"In that case hattheta=11 is the identity transform.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"This is the syntax we use to define our f_hattheta:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"recalibration_map = Map_Affine(X[1],X[end])","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"danger: Danger\nThis \"scaled\" parametrization breaks if one of X_A or X_B is null. You can always switch back to the more common (unscaled) affine interpolation formula by imposing X_A=1 or X_B=1:  Example: Map_Affine(X_A => 1, X_B => 1)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Now the recalibrable model hatm is defined as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"recalibration_model = Model2Fit_Recalibration(model,recalibration_map)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Now our unknown vector thetahattheta is:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"θ_map = Float64[1,1]\nθ_init_recalibration_model = vcat(θ_uncalibrated_model, θ_map)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"which is, in a more readable form, equivalent to:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"theta_textrecalibrable =  h_1 mu_1 sigma_1 h_2 mu_2 sigma_2 h_3 mu_3 sigma_3 hattheta_A hattheta_B","category":"page"},{"location":"recalibration/#The-bound-constrained-solver","page":"Peak fitting and recalibration","title":"The bound constrained solver","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We are nearly ready to solve our problem. Compared to the Simple Gaussian previous example we add bound constraints on θ.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The problem we want to solve is:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"minlimits_theta_l le theta le theta_u frac12Y-m(Xtheta)_2^2","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The objective function is defined as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"nls = NLS_ForwardDiff_From_Model2Fit(recalibration_model,X,Y)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The constraints are: ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"0 le h_i : we want positive peak heights.\nmu^texttrue_i = mu_i : peak centers are constants. If this was not the case, the recalibration mapping would be meaning less.\nepsilon le sigma_i : the Gaussian peak shape factor must be positives.\n05 le hattheta_i le 15 : we keep recalibration transform in a neighbourhood of the identity transform.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"This can be encoded as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"ε = eps(Float64)\n#                       h1 μ1   σ1,  h2  μ2   σ2   h3   μ3   σ3  θA   θB\nlower_bound = Float64[   0, 5,   ε,   0, 10,   ε,   0,  20,   ε, 0.5, 0.5]\nupper_bound = Float64[ Inf, 5, Inf, Inf, 10, Inf, Inf, 20, Inf, 1.5, 1.5]\n\nbc = NLS_Solver.BoundConstraints(lower_bound,upper_bound);","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We must now choose a bound constrained solver. We use the modified version of the Levenberg-Marquardt method with its default parameters:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"conf = NLS_Solver.LevenbergMarquardt_BC_Conf()","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can now solve the problem:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"result = NLS_Solver.solve(nls,θ_init_recalibration_model,bc,conf)","category":"page"},{"location":"recalibration/#Fit-result","page":"Peak fitting and recalibration","title":"Fit result","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"First, check that the method converged:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"NLS_Solver.converged(result)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"and plot the result:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"θ_fit_recalibration_model = NLS_Solver.solution(result)\nY_fit_recalibration_model = eval_y(recalibration_model,X,θ_fit_recalibration_model)\nplot!(X,Y_fit_recalibration_model, linewidth = 3, label = \"fitted model\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We see a good agreement between the data and the fitted model, however the plotted hatX is still the uncalibrated axe. What we want is the transformed one: X=f_hattheta(hatX). This calibrated X can computed as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X_recalibrated = eval_calibrated_x(recalibration_model,X,θ_fit_recalibration_model)\nplot(X_true, seriestype = :scatter, markershape = :xcross, label = \"true X\")\nplot!(X, seriestype = :scatter, label = \"miscalibrated X\")\nplot!(X_recalibrated, seriestype = :scatter, markershape = :cross, label = \"recalibrated X\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We see that we retrieved the right calibration:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"initial miss calibration","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"norm(X_true - X, Inf)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"recalibrated X","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"norm(X_true - X_recalibrated, Inf)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can also retrieve the initial model, the one that needs the calibrated X, with its parameters (the extra hattheta are removed). This model is our initial sum of the 3 Gaussian peaks:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"model == get_calibrated_model(recalibration_model)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"θ_fitted = get_calibrated_model_θ(recalibration_model,θ_fit_recalibration_model)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"With this, we can plot the model using the calibrated domain:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Y_fitted = eval_y(model, X_recalibrated, θ_fitted)\nplot(X_recalibrated,Y, seriestype = :scatter, label = \"raw data\")\nplot!(X_recalibrated,Y_fitted, linewidth = 3, label = \"fitted model (after recalibration)\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"we clearly see now that, after recalibration, the Gaussian peak centers 5, 10, 20 are consistent with the plot.","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of this package is to provide an easy to use framework to fit models like spectrum peaks.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"simple_fit.md\",\n    \"recalibration.md\",\n    \"mapped_parameters.md\",\n]\nDepth = 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"TODO: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag & visit method\nlinear parameters\nstacked models","category":"page"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"CurrentModule = NLS_Fit","category":"page"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"using NLS_Fit\nusing DelimitedFiles\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")","category":"page"},{"location":"model2fit_bestiary/#Model2Fit-bestiary","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"We try to catalog all the available 1D models.","category":"page"},{"location":"model2fit_bestiary/#Peak-models","page":"Model2Fit bestiary","title":"Peak models","text":"","category":"section"},{"location":"model2fit_bestiary/#Gaussian-peak","page":"Model2Fit bestiary","title":"Gaussian peak","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"See: Gaussian_Peak","category":"page"},{"location":"model2fit_bestiary/#Isotopic-motifs","page":"Model2Fit bestiary","title":"Isotopic motifs","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"Group several peaks together to form a peak motif.","category":"page"},{"location":"model2fit_bestiary/#Baseline-models","page":"Model2Fit bestiary","title":"Baseline models","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"TODO","category":"page"},{"location":"model2fit_bestiary/#Model-or-Parameter-transformations","page":"Model2Fit bestiary","title":"Model or Parameter transformations","text":"","category":"section"},{"location":"model2fit_bestiary/#Recalibration","page":"Model2Fit bestiary","title":"Recalibration","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"Useful to recalibrate signal knowing some peaks of well defined positions.","category":"page"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"See Model2Fit_Recalibration .","category":"page"},{"location":"model2fit_bestiary/#Shared-parameters","page":"Model2Fit bestiary","title":"Shared parameters","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"See Model2Fit_Shared_Parameters ","category":"page"},{"location":"model2fit_bestiary/#Mapped-parameters","page":"Model2Fit bestiary","title":"Mapped parameters","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"See Model2Fit_Mapped_Parameters ","category":"page"},{"location":"model2fit_bestiary/#Constant-parameters","page":"Model2Fit bestiary","title":"Constant parameters","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"See Model2Fit_Const_Parameters ","category":"page"},{"location":"model2fit_bestiary/#Stacked-parameters","page":"Model2Fit bestiary","title":"Stacked parameters","text":"","category":"section"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"Useful when you have several ROIs.","category":"page"},{"location":"model2fit_bestiary/","page":"Model2Fit bestiary","title":"Model2Fit bestiary","text":"See Model2Fit_Stacked ","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Doc","page":"API","title":"Doc","text":"","category":"section"},{"location":"API/#Public","page":"API","title":"Public","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [NLS_Fit]\nPrivate = false","category":"page"},{"location":"API/#NLS_Fit.Abstract_Model2Fit","page":"API","title":"NLS_Fit.Abstract_Model2Fit","text":"Abstract type, base of all model to fit.\n\nInterface\n\nThe interface is very simple\n\nparameter_size \naccumulate_y! \n\nConvenience functions\n\neval_y \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Gaussian_Peak","page":"API","title":"NLS_Fit.Gaussian_Peak","text":"Gaussian peak\n\np(x θ = hμσ) = h e^-frac12 left(fracx-μσ right)^2\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Map_Affine","page":"API","title":"NLS_Fit.Map_Affine","text":"Map_Affine(X_hat_A => X_A, X_hat_B => X_B)\n\nMap_Affine(X_hat_A, X_hat_B)\n\nThe second constructor is a shortcut for\n\nMap_Affine(X_hat_A => X_hat_A, X_hat_B => X_hat_B)\n\nDefines an affine transformation:\n\nX(hatX) = L_A(hatX) X_A θ_A +  L_B(hatX) X_B θ_B\n\nwhere L_A and L_B are the Lagrange basis.\n\nIn peculiar, for (θ_Aθ_B) = (11) we have an affine map such that X(hatX_A) = X_A and X(hatX_B) = X_B.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Map_Affine_Monotonic","page":"API","title":"NLS_Fit.Map_Affine_Monotonic","text":"Map_Affine_Monotonic(X_hat_A => X_A, X_hat_B => X_B)\n\nMap_Affine_Monotonic(X_hat_A, X_hat_B)\n\nThe second constructor is a shortcut for\n\nMap_Affine_Monotonic(X_hat_A => X_hat_A, X_hat_B => X_hat_B)\n\nSame as Map_Affine but uses another parametrization that allows to insure monotonic map using simple bound constraints.\n\nThe Map_Affine map is defined as follows:\n\nX(hatX) = L_A(hatX) X_A θ_A +  L_B(hatX) X_B θ_B\n\nWith this parametrization you have to add the X_B θ_B  X_A θ_A to insure that the map is increasing.\n\nOn the other hand, with the Map_Affine_Monotonic parametrization:\n\nX(hatX) = L_A(hatX) X_A θ_A +  L_B(hatX) ( (X_B-X_A) θ_B + X_A θ_A )\n\nwhere \n\nfracdXdhatX = fracX_B-X_AhatX_B-hatX_A θ_B\n\na simply bound constraint θ_B  0 is sufficient to preserve the increasing or decreasing character. This preserved slope is given by the sign of fracX_B-X_AhatX_B-hatX_A which is constant once the structure has been initialized.\n\nIn peculiar, for (θ_Aθ_B) = (11) we have an affine map such that X(hatX_A) = X_A and X(hatX_B) = X_B. Whereas for (θ_Aθ_B) = (10) we have a constant one.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Map_From_VectFunc","page":"API","title":"NLS_Fit.Map_From_VectFunc","text":"An Abstract_Map instance that can be easily created by providing a Julia function\n\nConstructor\n\nMap_From_VectFunc(n_θ,f)\n\nwhere (Xθ)-Y=f(Xθ) is the wrapped function.\n\nExample\n\nusing NLS_Fit\n\nf(X,θ) = θ[1]*X\n\nmap = Map_From_VectFunc(1,f)\n\nX = Float64[1,2,3]\n\nθ = Float64[4]\n\neval_map(map,X,θ)\n\n# output\n3-element Vector{Float64}:\n  4.0\n  8.0\n 12.0\n\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Map_Translate","page":"API","title":"NLS_Fit.Map_Translate","text":"Map_Translate(;scale = 1)\n\nDefines a translate transformation:\n\nX(hatX) = hatX + scale (θ - 1)\n\nIn peculiar, for (θ) = (1) the transformation is identity.  This is due to the presence of the θ- 1 factor. This factor is introduced to stay consistent with other transformations where we try to have identity transform for parameter vector of ones.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Const_Parameters","page":"API","title":"NLS_Fit.Model2Fit_Const_Parameters","text":"Set some parameters to constant values\n\nExample\n\nLet's assume that we have an initial model model with θ as parameter vector.  If we want θ1, θ3, θ5 to be constant, proceed as follows\n\nindices = [1,3,5]\nvalues = Float64[1,2,3]\n        \nmodel_with_const_params = Model2Fit_Const_Parameters(model, indices, values)\n\nDo not forget to udpate parameter vector θ, this can be done as follows:\n\ndeleteat!(θ, indices)\n\nAlso see\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Empty","page":"API","title":"NLS_Fit.Model2Fit_Empty","text":"An empty model without parameters. This is useful to initialize summation:\n\nmodel = Model2Fit_Empty()\n\nfor i in 1:n\n    model = model + GaussianPeak()\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Mapped_Parameters","page":"API","title":"NLS_Fit.Model2Fit_Mapped_Parameters","text":"Create a new model, where some parameters are computed using a Abstract_Map.\n\nTODO: not clear how to use it: certainly need a refactoring...\n\nAlso see\n\nModel2Fit_Shared_Parameters \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Recalibration","page":"API","title":"NLS_Fit.Model2Fit_Recalibration","text":"Create a calibrable model\n\nMore precisely, from an initial model m and a map f, create a new model hatm such that:\n\nhatm(hatXhattheta=hattheta_mhattheta_f) = m(X=f_hattheta_f(hatX)hattheta_m)\n\nIn Julia code this means that \n\neval_y(calibrable_model,X_hat,[θ̂m, θ̂f])\n\nis replaced by\n\neval_y(model_to_calibrate, eval_calibrated_x(X_hat, θ̂f), [θ̂m])\n\nConstructors\n\ncalibrable_model = Model2Fit_Recalibration(model_to_calibrate, calibration_map)\n\nwhere model_to_calibrate is an Abstract_Model2Fit and calibration_map is an Abstract_Map\n\nAlso see\n\nget_calibration_map \nget_calibration_map_θ \nget_calibrated_model \nget_calibrated_model_θ \neval_calibrated_x \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Shared_Parameters","page":"API","title":"NLS_Fit.Model2Fit_Shared_Parameters","text":"Share a set of parameters\n\nExample\n\nLet's assume that we have an initial model model with θ as parameter vector.  If we want θ1, θ3, θ5 to share a same value θshared then:\n\nindices_to_share = [1,3,5]\n        \nmodel_with_shared_params = Model2Fit_Shared_Parameters(model, indices_to_share)\n\nDo not forget to udpate parameter vector θ, this can be done as follows:\n\ndeleteat!(θ, indices_to_share)\npush!(θ, θshared)\n\nAlso see\n\nModel2Fit_Mapped_Parameters \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Stacked","page":"API","title":"NLS_Fit.Model2Fit_Stacked","text":"Define a composite model, where each submodel is responsible of a given ROI\n\n| (1)        | (2)       | ...  |––––––|–––––-| ... | models[1]  | model[2]  | ...\n\nDomain (1) range is defined as 1:ROIsizes[1] Domain (2) range is defined as (ROIsizes[1]+1):ROI_sizes[2] etc...\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_TaggedModel","page":"API","title":"NLS_Fit.Model2Fit_TaggedModel","text":"Model2Fit_TaggedModel(model,data)\n\nTag model and embed data\n\nExtra method\n\nget_tagged_data \nget_tagged_model \nget_tagged_data_type \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Transformed_Parameters","page":"API","title":"NLS_Fit.Model2Fit_Transformed_Parameters","text":"Create a new model, where the  parameter vector theta is computed using an Abstract_Map:\n\n hatthetamapsto theta = f_hattheta_f(hattheta_m)\n\nThe resulting model is thus:\n\nhatm(Xhattheta=hattheta_mhattheta_f) = m(Xtheta = f_hattheta_f(hattheta_m))\n\nConstructor\n\nGeneral case\n\nModel2Fit_Transformed_Parameters(model::Abstract_Model2Fit,\n                                 map_domain_size::Int,\n                                 map::Abstract_Map)\n\nmap_domain_size is the expected hattheta_m size. This quantity is used to implement model parameter_size() method. The reason is that the current Abstract_Map interface only provides hattheta_f size (its parameter_size() method) but tells nothing about hattheta_m size.\nAlso, please note that theta size is not necessary equal to hattheta_m size\n\nUsing Transform_Src_Insert_Dest_Map\n\nVery often this structure is used with a map of type Transform_Src_Insert_Dest_Map. In that case it is simpler to use a dedicated function: create_model_transform_src_insert_dest (follow this link to see an example).\n\nExample\n\nTODO: add an example using the general constructor\n\nExtra methods\n\nBeside the regular Abstract_Model2Fit interface, you can use these extra methods:\n\nget_model(model::Model2Fit_Transformed_Parameters) \nget_model_θ(hat_model::Model2Fit_Transformed_Parameters,hat_θ::AbstractVector) \n\nNot exported\n\nThese methods are not exported but may be useful:\n\nget_model_hat_θ_view(hat_model::Model2Fit_Transformed_Parameters,hat_θ::AbstractVector) \nget_map_hat_θ_view(hat_model::Model2Fit_Transformed_Parameters,hat_θ::AbstractVector) \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.NLS_ForwardDiff_From_Model2Fit","page":"API","title":"NLS_Fit.NLS_ForwardDiff_From_Model2Fit","text":"A wrapper that allows to use the NLS_Solver.jl package to solve the nonlinear least squares problem associated to a model plus its (X,Y) data.\n\nYou must construct an instance of nls problem as follows:\n\nNLS_ForwardDiff_From_Model2Fit(fit_model::MODEL2FIT_TYPE,\n                               X::X_TYPE,\n                               Y::Y_TYPE)\n\nYou can then use the NLS_Solver package as usual, but with prefixed NLS_Solver.\n\nnls = NLS_ForwardDiff_From_Model2Fit(model,X,Y)\nconf = NLS_Solver.LevenbergMarquardt_Conf()\nresult = NLS_Solver.solve(nls,θ_init,conf)\n\nCAVEAT:\n\nPlease note that you should not explicitly\n\nusing NLS_Solver\n\nas this package is reexported from NLS_Fit.  Doing so avoids potential version compatibility problems.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.accumulate_y!-Tuple{Abstract_Model2Fit, AbstractVector, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.accumulate_y!","text":"accumulate_y!(::Abstract_Model2Fit,Y::AbstractVector,X::AbstractVector,θ::AbstractVector)::AbstractVector\n\nAccumulate model contribution into vector Y.\n\nAlso see\n\nAbstract_Model2Fit\neval_y \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.create_model_transform_src_insert_dest-Union{Tuple{DEST}, Tuple{SOURCE}, Tuple{Abstract_Model2Fit, NLS_Fit.Abstract_Map, Pair{SOURCE, DEST}}} where {SOURCE<:AbstractVector{Int64}, DEST<:AbstractVector{Int64}}","page":"API","title":"NLS_Fit.create_model_transform_src_insert_dest","text":"This function creates an Model2Fit_Transformed_Parameters instance from a map of type Transform_Src_Insert_Dest_Map.\n\nfunction create_model_transform_src_insert_dest(model, map, src=>dest) -> model\n\nExample\n\nusing NLS_Fit\n\n# Two Gaussian peaks with σ(μ) an affine function\n#\nmodel = Gaussian_Peak() + Gaussian_Peak() \n\n# model θ is:\n# idx:  1   2  3   4   5   6\n#  θ : h1, μ1, σ1, h2, μ2, σ2\n#\n# hence:\n#\nsrc  = [2,5]\ndest = [3,6]\n\n# The σ(μ) relation: σ(μ=1)=1 and σ(μ=100)=10 for [θ̂A, θ̂B]=[1, 1]\n#\nf_σ_μ = Map_Affine(1.0=>1.0,100.0=>10.0)\n\n# Now the model_σ_μ parameters are:\n#\n# [ h1, μ1, h2, μ2, θ̂A, θ̂B ]\n#\n# the initial model is called with:\n#\n# [ h1, μ1, σ1 = affine(μ1, θ̂A, θ̂B), h2, μ2, , σ2 = affine(μ2, θ̂A, θ̂B) ]\n#\nmodel_σ_μ = create_model_transform_src_insert_dest(model,f_σ_μ,src=>dest)\n\n# Examine that the compute θ takes into account the σ(μ) dependance:\n#\nθ̂ = Float64[1,5, 2, 95, 1, 1]\nθ = get_model_θ(model_σ_μ, θ̂)\n\n# output\n6-element Vector{Float64}:\n  1.0\n  5.0\n  1.3636363636363638\n  2.0\n 95.0\n  9.545454545454547\n\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.eval_calibrated_x-Tuple{Model2Fit_Recalibration, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.eval_calibrated_x","text":"eval_calibrated_x(m::Model2Fit_Recalibration,X_hat::AbstractVector,θ::AbstractVector) -> AbstractVector\n\nCompute the calibrated X from the reference domain hatX for the given transformation parameters θ.\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.eval_map-Tuple{NLS_Fit.Abstract_Map, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.eval_map","text":"eval_map(m::Abstract_Map,X_hat::AbstractVector,hat_θ::AbstractVector) -> X::AbstractVector\n\nCompute X=X(hatX).\n\nSee also\n\nAbstract_Map \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.eval_y-Tuple{Abstract_Model2Fit, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.eval_y","text":"eval_y(m::Abstract_Model2Fit,X::AbstractVector,θ::AbstractVector)::AbstractVector\n\nA convenience function that call accumulate_y! using a zero initialized Y vector. This returned vector contains model values.\n\nAlso see\n\nAbstract_Model2Fit\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibrated_model-Tuple{Model2Fit_Recalibration}","page":"API","title":"NLS_Fit.get_calibrated_model","text":"get_calibrated_model(model::Model2Fit_Recalibration)::Abstract_Model2Fit\n\nRetrieve the underlying model to calibrate\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibrated_model_θ-Tuple{Model2Fit_Recalibration, AbstractVector}","page":"API","title":"NLS_Fit.get_calibrated_model_θ","text":"get_calibrated_model_θ(model::Model2Fit_Recalibration,\n                       θ::AbstractVector)::AbstractVector\n\nRetrieve the parameter vector of the underlying model to calibrate\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibration_map-Tuple{Model2Fit_Recalibration}","page":"API","title":"NLS_Fit.get_calibration_map","text":"get_calibration_map(model::Model2Fit_Recalibration)::Abstract_Map\n\nRetrieve the calibration map, of type Abstract_Map.\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibration_map_θ-Tuple{Model2Fit_Recalibration, AbstractVector}","page":"API","title":"NLS_Fit.get_calibration_map_θ","text":"get_calibration_map_θ(model::Model2Fit_Recalibration,\n                      θ::AbstractVector)::AbstractVector\n\nRetrieve the calibration map parameters\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model-Tuple{Model2Fit_Const_Parameters}","page":"API","title":"NLS_Fit.get_model","text":"get_model(model::Model2Fit_Const_Parameters) -> Absatrct_Model2Fit\n\nGet back the wrapped model\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model-Tuple{Model2Fit_Mapped_Parameters}","page":"API","title":"NLS_Fit.get_model","text":"get_model(mp::Model2Fit_Mapped_Parameters) -> Absatrct_Model2Fit\n\nGet back the wrapped model\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model-Tuple{Model2Fit_Shared_Parameters}","page":"API","title":"NLS_Fit.get_model","text":"get_model(mp::Model2Fit_Shared_Parameters) -> Absatrct_Model2Fit\n\nGet back the wrapped model\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model-Tuple{Model2Fit_Transformed_Parameters}","page":"API","title":"NLS_Fit.get_model","text":"get_model(mp::Model2Fit_Transformed_Parameters)::Abstract_Model2Fit\n\nGet back the wrapped model\n\nSee Model2Fit_Transformed_Parameters \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model_θ-Tuple{Model2Fit_Const_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_model_θ","text":"get_model_θ(mp::Model2Fit_Const_Parameters,θ::AbstractVector) -> θ::AbstractVector\n\nRetrieve the parameter vector θ associated to the wrapped model get_model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model_θ-Tuple{Model2Fit_Mapped_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_model_θ","text":"get_model_θ(mp::Model2Fit_Mapped_Parameters,θ::AbstractVector) -> θ::AbstractVector\n\nRetrieve the parameter vector θ associated to the wrapped model get_model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model_θ-Tuple{Model2Fit_Shared_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_model_θ","text":"get_model_θ(mp::Model2Fit_Shared_Parameters,θ::AbstractVector) -> θ::AbstractVector\n\nRetrieve the parameter vector θ associated to the wrapped model get_model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model_θ-Tuple{Model2Fit_Transformed_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_model_θ","text":"get_model_θ(mp::Model2Fit_Transformed_Parameters, hat_θ::AbstractVector) -> θ::AbstractVector\n\nRetrieve the parameter vector θ associated to the wrapped model get_model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_data-Tuple{Model2Fit_TaggedModel}","page":"API","title":"NLS_Fit.get_tagged_data","text":"get_tagged_data(m::Model2Fit_TaggedModel{MODEL,DATA)::DATA\n\nReturn embedded data\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_data_type-Tuple{Abstract_Model2Fit}","page":"API","title":"NLS_Fit.get_tagged_data_type","text":"get_tagged_data_type(m::Abstract_Model2Fit)::DataType\n\nReturn embedded data type, or Nothing if m is not a Model2Fit_TaggedModel.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_model-Tuple{Model2Fit_TaggedModel}","page":"API","title":"NLS_Fit.get_tagged_model","text":"get_tagged_model(m::Model2Fit_TaggedModel{MODEL,DATA)::DATA\n\nReturn tagged model\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_model_type-Tuple{Abstract_Model2Fit}","page":"API","title":"NLS_Fit.get_tagged_model_type","text":"get_tagged_model_type(m::Abstract_Model2Fit)::DataType\n\nReturn wrapped model type, or Nothing if m is not a Model2Fit_TaggedModel.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.insert_some_elements","page":"API","title":"NLS_Fit.insert_some_elements","text":"insert_some_elements(X::AbstractVector{T},\n                     indices::AbstractVector{Int},\n                     elements::AbstractVector) -> AbstractVector{T}\n\nInsert elements in X at positions indices.\n\nNote: indices must be strictly ordered.\n\nExample: this functions does a work inverse to the deleteat!\n\njulia> X = Any[1:10;]\n10-element Vector{Any}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\njulia> indices = Int[2, 3, 5, 6, 9, 10];\n\njulia> elements = Float64[2, 3, 5, 6, 9, 10];\n\njulia> deleteat!(X, indices)\n4-element Vector{Any}:\n 1\n 4\n 7\n 8\n\njulia> insert_some_elements(X,indices,elements)\n10-element Vector{Any}:\n  1\n  2.0\n  3.0\n  4\n  5.0\n  6.0\n  7\n  8\n  9.0\n 10.0\n\n\n\n\n\n\n","category":"function"},{"location":"API/#NLS_Fit.parameter_size-Tuple{Abstract_Model2Fit}","page":"API","title":"NLS_Fit.parameter_size","text":"parameter_size(::Abstract_Model2Fit)::Int\n\nReturn length of the expected parameter vector θ\n\nAlso see\n\nAbstract_Model2Fit\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.parameter_size-Tuple{NLS_Fit.Abstract_Map}","page":"API","title":"NLS_Fit.parameter_size","text":"parameter_size(::Abstract_Map) -> Int\n\nReturn hatθ parameter vector length\n\nSee also\n\nAbstract_Map \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.solve_linear_parameters-Tuple{Abstract_Model2Fit, AbstractVector, AbstractVector, AbstractVector, AbstractVector{Int64}}","page":"API","title":"NLS_Fit.solve_linear_parameters","text":"Find optimal linear parameters\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.visit-Tuple{Function, Abstract_Model2Fit, AbstractVector, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.visit","text":"visit(mp::Abstract_Model2Fit,X::AbstractVector,θp::AbstractVector,action::Function) -> nothing\n\nRecursively visit models using a depth-first-order.\n\nFor each visited model, performian action which is a function of type\n\nvisit_default_action(m::Abstract_Model2Fit,x::AbstractVector,θ::AbstractVector)  -> Bool\n\nIf the function returns false the depth-first-search is stopped.\n\nImplementation details\n\nThe visit functionality requires these methods to be defined for each visited model:\n\nvisit_submodel_size(model)\nvisit_get_submodel(model,submodel_idx)\nvisit_get_Y(model,submodel_idx,Y,X,θ)\nvisit_get_X(model,submodel_idx,Y,X,θ)\nvisit_get_θ(model,submodel_idx,Y,X,θ)\n\nThere is no need to export these methods.\n\nThese functions never modifies Y components, in some cases like Model2Fit_Stacked, visit_get_Y returns a view.\n\n\n\n\n\n","category":"method"},{"location":"API/#Private","page":"API","title":"Private","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [NLS_Fit]\nPublic = false","category":"page"},{"location":"API/#NLS_Fit.Abstract_Map","page":"API","title":"NLS_Fit.Abstract_Map","text":"abstract type Abstract_Map end\n\nThis type is an abstraction of a \n\nfX  Y=f_hattheta(X)\n\nwhere hattheta is map parameter vector.\n\nSuch transformations can be used in various contexts: \n\ncalibration task: we have a reference hatX to a calibrated X, see Model2Fit_Recalibration.\nparameter transformation: we map a parameter vector hatθ to a new one θ, see Model2Fit_Transformed_Parameters.\n\nInterface\n\nparameter_size\neval_map \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Transform_Src_Insert_Dest_Map","page":"API","title":"NLS_Fit.Transform_Src_Insert_Dest_Map","text":"Define a map g of the form\n\ntheta = g_hattheta_f(hattheta_m)\n\nWhere the resulting theta vector is computed as follows:\n\ncompute tau=f_hattheta_f(hattheta_mtextsrc) an intermediate vector tau using the wrapped map f action on a subset of the hattheta_m vector. This subset being defined by an index array src.\ncreate the resulting theta by inserting components of tau into the hattheta_m vector at indices stored in an index array dest (src and dest have the same length).\n\nThis is certainly more comprehensible with an example.\n\nExample\n\nusing NLS_Fit\n\nf(θ̂m_src,θ̂f) = θ̂f[1] .+ θ̂f[2] * θ̂m_src\n\nf_map = Map_From_VectFunc(2,f)\nθ̂f    = Float64[0,-1] # change sign\n\n# insert -θ̂m[4], at position 2\n# insert -θ̂m[1], at position 3\nsrc  = [4,1]\ndest = [2,3]\n\n# delete elements that are going to be computed & inserted \n#\n# we see that elements of `src` indices are kept, \n# whereas elements of `dest` indices are removed\n#\nθ̂m = Float64[1:5;]       #  [1,2,3,4,5] \nθ̂m = deleteat!(θ̂m,dest)  #  [1,4,5]\n\nmap_s_d = NLS_Fit.Transform_Src_Insert_Dest_Map(f_map,src=>dest)\n\nθ = eval_map(map_s_d,θ̂m,θ̂f)\n\n# output\n5-element Vector{Float64}:\n  1.0\n -4.0\n -1.0\n  4.0\n  5.0\n\nConstructor\n\nTransform_Src_Insert_Dest_Map(f_map, src=>dest)\n\nf_map is the stored Abstract_Map map,\nsrc=>dest is a pair of two Int vectors used to define indices. Note that we must have src ∩ dest = ∅. The reason is that as dest indices are removed, there would no more associated src component to apply f\n\nAlso see\n\nThis map can be directly used by Model2Fit_Transformed_Parameters.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.get_map_hat_θ_view-Tuple{Model2Fit_Transformed_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_map_hat_θ_view","text":"get_model_hat_θ_view(hat_model::Model2Fit_Transformed_Parameters,hat_θ::AbstractVector)\n\nReturn a view on hattheta_f knowing hattheta=hattheta_mhattheta_f\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model_hat_θ_view-Tuple{Model2Fit_Transformed_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_model_hat_θ_view","text":"get_model_hat_θ_view(hat_model::Model2Fit_Transformed_Parameters,hat_θ::AbstractVector)\n\nReturn a view on hattheta_m knowing hattheta=hattheta_mhattheta_f\n\n\n\n\n\n","category":"method"}]
}
