var documenterSearchIndex = {"docs":
[{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"CurrentModule = NLS_Fit","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"using NLS_Fit\nusing DelimitedFiles\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")","category":"page"},{"location":"constrained_parameters/#Constrained-parameters","page":"Constrained parameters","title":"Constrained parameters","text":"","category":"section"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"You can reproduce the following computation using sandbox/constrained_parameters.jl.","category":"page"},{"location":"constrained_parameters/#Data-and-model","page":"Constrained parameters","title":"Data and model","text":"","category":"section"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"In this example there are 3 Gaussian peaks with different shape factors sigma_1 sigma_2 sigma_3. The goal here is to constrain these shape factors to have an affine dependence with respect to X.","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"Let us plot the initial data and model.","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"model = Gaussian_Peak() + Gaussian_Peak() + Gaussian_Peak()\n\nθ1 = Float64[1,5,1]\nθ2 = Float64[1,10,1]\nθ3 = Float64[1,20,1]\n\nθ_model = vcat(θ1,θ2,θ3)","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"This parameter vector is:","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"h_1 mu_1 sigma_1 h_2 mu_2 sigma_2 h_3 mu_3 sigma_3","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"XY=readdlm(joinpath(dataDir,\"constrained_parameters.txt\")) # hide\nX = XY[:,1] # hide\nY = XY[:,2] # hide\nplot(X,Y, seriestype = :scatter, label = \"raw data\")\n\nY_model = eval_y(model,X,θ_model)\nplot!(X,Y_model, label = \"initial model\")","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"For the model the three shape factors are sigma_i=1. The data has been generated with (sigma_1 sigma_2 sigma_3=(1152).","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"It often happens that we want to constraint some parameters to follow a given law. Here we want to create a model where σ follows an affine law:","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"σ(X) = L_A(X) σ_A θ_A + L_B(X) σ_B θ_B ","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"where L_A L_B are the Lagrange basis.","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"A detailed description about this affine function parametrization is given in A model for calibration.","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"# define a map:  X_A => σ_A,  X_B => σ_B\nmap_pos2sigma = Map_Affine(1.0  => 1.0, 30.0 => 5.0)\n# initial parameter value\nθ_map = ones(NLS_Fit.parameter_size(map_pos2sigma))\nnothing # hide","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"We now create a vector of components mu_1 mu_2 mu_3. This components are the 3 Gaussian peak positions. These positions are used find sigma_i=sigma(μ_i) using the map_pos2sigma. To write these shape factors at the right emplacements in the θ_model vector we also need the indices of the sigma_1 sigma_2 sigma_3 parameters.","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"σ_indices = [3,6,9]\nref_pos   = [5.0, 10.0, 20.0]\nnothing # hide","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"We now have all the required information to create the model where the 3 shape factors follow the affine law sigma(X):","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"model_with_σ_law = Model2Fit_Mapped_Parameters(model,map_pos2sigma,σ_indices,ref_pos)\nnothing # hide","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"The new parameter vector θ_model_with_σ_law is build from the initial parameter vector θ_model. We must first remove the parameters associated to sigma_1 sigma_2 sigma_3 (as there are going to be replaced by sigma(mu_1) sigma(mu_2) sigma(mu_3)). We then have to add the map_pos2sigma extra parameters. All these modifications can be performed by:","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"θ_model_with_σ_law = vcat(deleteat!(copy(θ_model),σ_indices),θ_map)","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"This parameter vector is of the form:","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"h_1 mu_1 h_2 mu_2 h_3 mu_3 theta_A theta_B","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"We can easily retrieve the parameters vector θ_model with values induces by the map_pos2sigma transformation:","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"get_model_θ(model_with_σ_law,θ_model_with_σ_law)","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"We see that the model with its initial θ_model_with_σ_law parameter vector overestimate the shape factor sigma_i. This is also visible if we plot the model Y value:","category":"page"},{"location":"constrained_parameters/","page":"Constrained parameters","title":"Constrained parameters","text":"Y_model_with_σ_law = eval_y(model_with_σ_law,X,θ_model_with_σ_law)\nplot!(X,Y_model_with_σ_law, label = \"initial model with constrained σ\")","category":"page"},{"location":"constrained_parameters/#Fit","page":"Constrained parameters","title":"Fit","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"CurrentModule = NLS_Fit","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"using NLS_Fit\nusing DelimitedFiles\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")","category":"page"},{"location":"simple_fit/#Simple-fit","page":"Simple fit","title":"Simple fit","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"You can reproduce the following computation using sandbox/simple_gaussian.jl.","category":"page"},{"location":"simple_fit/#Data-and-model","page":"Simple fit","title":"Data and model","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The first example is a simple Gaussian peak fit. We use the data/simple_gaussian.txt data file. ","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"XY=readdlm(joinpath(dataDir,\"simple_gaussian.txt\")) # hide\nX = XY[:,1] # hide\nY = XY[:,2] # hide\nplot(X,Y, seriestype = :scatter, label = \"raw data\")","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The model is a single Gaussian peak. ","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"model = Gaussian_Peak()","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The model does no embeds its model parameters. So before being able to evaluate model values one must define a parameter vector θ. For Gaussian_Peak, this vector is [h,μ,σ]. It stores the peak height, its center and its shape factor.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"θ_init = Float64[1,10,5]","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We now have everything we need to evaluate model values. This is the role of the eval_y function. This function compute model Y values given its parameter vector θ and the evaluation sites X.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"Y_init = eval_y(model,X,θ_init)\nplot!(X,Y_init, label = \"initial model\")","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We see that the parameter vector θ is not a good guess to fit the peak to the raw data. We will see now how to automatically adjust these parameters using a Levenberg-Marquardt like method.","category":"page"},{"location":"simple_fit/#Model-fitting","page":"Simple fit","title":"Model fitting","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"This package embeds the NLS_Solver.jl package to perform nonlinear least squares regressions. To use it you simply have to add the NLS_Solver prefix. The example below explains this in details.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We want to solve this nonlinear least squares problem:","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"minlimits_theta frac12Y-m(Xtheta)_2^2","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"The objective function is created as follows:","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"nls = NLS_ForwardDiff_From_Model2Fit(model,X,Y)","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We now select the solver, here the Levenberg-Marquardt method","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"conf = NLS_Solver.LevenbergMarquardt_Conf()","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"and solve the problem:","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"result = NLS_Solver.solve(nls,θ_init,conf)","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"Note that we have used the NLS_Solver. prefix, without importing again the NLS_Solver.jl package.","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"danger: Caveat\nDo not re-import the NLS_Solver.jl package by typing using NLS_Solver.  As NLS_Fit already embeds this package, this may cause versions conflicts. The right way to go is to add a NLS_Solver prefix when you need some of the NLS_Solver.jl package functionalities.","category":"page"},{"location":"simple_fit/#Fit-result","page":"Simple fit","title":"Fit result","text":"","category":"section"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"We can check that the solver converged","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"NLS_Solver.converged(result)","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"and plot the fitted model","category":"page"},{"location":"simple_fit/","page":"Simple fit","title":"Simple fit","text":"θ_fit = NLS_Solver.solution(result)\nY_fit = eval_y(model,X,θ_fit)\nplot!(X,Y_fit, label = \"fitted model\", linewidth=3)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"CurrentModule = NLS_Fit","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"using NLS_Fit\nusing DelimitedFiles\nusing LinearAlgebra\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")","category":"page"},{"location":"recalibration/#Peak-fitting-and-recalibration","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"You can reproduce the following computation using sandbox/recalibration.jl.","category":"page"},{"location":"recalibration/#Problem-description-and-data","page":"Peak fitting and recalibration","title":"Problem description and data","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"In this problem one must fit 3 Gaussian peaks at positions 5, 10, 20. However the loaded data (X,Y) presents a miscalibrated X. This miscalibrated X is computed from The \"true\" X as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X = 11 X_texttrue + 02","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The complete process to generate the synthetic data is:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"using DelimitedFiles,Random\nusing NLS_Fit\n\nRandom.seed!(1234)\n\nmodel = Gaussian_Peak() + Gaussian_Peak() + Gaussian_Peak()\nθ1 = Float64[1,5,1]\nθ2 = Float64[1.5,10,2]\nθ3 = Float64[0.75,20,3]\nθ = vcat(θ1,θ2,θ3)\n\nX=Float64[1:0.25:30;]\nn=length(X)\nY=eval_y(model,X,θ) + 0.1*(rand(n) .- 0.5)\n\n@. X = 1.1*X + 0.2 # inverse map is: 0.91 * X - 0.18\n\nrootDir = joinpath(dirname(pathof(NLS_Fit)), \"..\")\ndataDir = joinpath(rootDir,\"data\")\ndataFile = joinpath(dataDir,\"recalibration.txt\")\nwritedlm(dataFile,hcat(X,Y))\n\n","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"If we plot this, we get:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"XY=readdlm(joinpath(dataDir,\"recalibration.txt\")) # hide\nX = XY[:,1] # hide\nY = XY[:,2] # hide\nplot(X,Y, seriestype = :scatter, label = \"raw data\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can also plot miscalibrated X and the \"true\" one X_texttrue. We only now X, but as we generated artificial data, we know that ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X = 11 X_texttrue + 02","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"which can easily be inverted to give ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X_texttrue = (X - 02)11","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can now plot both X and X_texttrue:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X_true = (X .- 0.2)/1.1\nplot(X_true, seriestype = :scatter, markershape = :xcross, label = \"true X\")\nplot!(X, seriestype = :scatter, label = \"miscalibrated X\")","category":"page"},{"location":"recalibration/#The-model","page":"Peak fitting and recalibration","title":"The model","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The first step is to define an uncalibrated model.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"model = Gaussian_Peak() + Gaussian_Peak() + Gaussian_Peak()\n\nθ1 = Float64[1.0,5,1]\nθ2 = Float64[1.5,10,2]\nθ3 = Float64[0.75,20,3]\nθ_uncalibrated_model = vcat(θ1,θ2,θ3)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"This model is the sum of three Gaussian peaks, its parameter vector θ is","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"theta =  h_1 mu_1 sigma_1 h_2 mu_2 sigma_2 h_3 mu_3 sigma_3","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Even if the centers mu_1 mu_2 mu_3 are corrects, the peaks are miss positioned due to the bad calibration:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Y_uncalibrated_model = eval_y(model,X,θ_uncalibrated_model)\n\nplot(X,Y, seriestype = :scatter, label = \"raw data\")\nplot!(X,Y_uncalibrated_model, label = \"uncalibrated model\")","category":"page"},{"location":"recalibration/#A_model_for_calibration","page":"Peak fitting and recalibration","title":"A model for calibration","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The idea to create a recalibrable model hatm is as follows. We use an initial model m(thetahatX) to create a new one where the spatial variable hatX is transformed X=f_hattheta(hatX):","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"hatm(thetahatthetahatX)=m(thetaX=f_hattheta(hatX))","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"With this approach, the initial model m sees the calibrated X. The calibration map, f_hattheta is parameterized by hattheta. The create calibrable model is defined by a new parameter vector of the form thetahattheta.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"For the current example we will use an affine function for f_hattheta. This function is defined as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"f_hattheta(hatX) = L_A(hatX)X_Ahattheta_A + L_B(hatX)X_Bhattheta_B","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"where L_A L_B are the Lagrange basis, ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"L_A(hatX)=frachatX_B-hatXhatX_B-hatX_A  L_B(hatX)=frachatX-hatX_AhatX_B-hatX_A","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We remark that for hattheta= hattheta_Ahattheta_B=11 the transform f_hattheta is the transform that maps  hatX_A to X_A and hatX_B to X_B. This did not happen by chance.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"note: Note\nWhenever possible we try to use parametrizations such that hattheta=1dots1 has a  special role, like identity transform. This hattheta=1dots1 can be used as parameter  initial value. This is important from a numerical point of view, where it is better to have an  unknown vector theta where all components have the same order of magnitude.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"On the Julia side, the affine transform f_hattheta is declared as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Map_Affine(hat_X_A => X_A, hat_X_B => X_B)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"whereas the shortened version","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Map_Affine(X_A, X_B)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"means","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Map_Affine(X_A => X_A, X_B => X_B)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"In that case hattheta=11 is the identity transform.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"This is the syntax we use to define our f_hattheta:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"recalibration_map = Map_Affine(X[1],X[end])","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"danger: Danger\nThis \"scaled\" parametrization breaks if one of X_A or X_B is null. You can always switch back to the more common (unscaled) affine interpolation formula by imposing X_A=1 or X_B=1:  Example: Map_Affine(X_A => 1, X_B => 1)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Now the recalibrable model hatm is defined as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"recalibration_model = Model2Fit_Recalibration(model,recalibration_map)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Now our unknown vector thetahattheta is:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"θ_map = Float64[1,1]\nθ_init_recalibration_model = vcat(θ_uncalibrated_model, θ_map)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"which is, in a more readable form, equivalent to:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"theta_textrecalibrable =  h_1 mu_1 sigma_1 h_2 mu_2 sigma_2 h_3 mu_3 sigma_3 hattheta_A hattheta_B","category":"page"},{"location":"recalibration/#The-bound-constrained-solver","page":"Peak fitting and recalibration","title":"The bound constrained solver","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We are nearly ready to solve our problem. Compared to the Simple Gaussian previous example we add bound constraints on θ.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The problem we want to solve is:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"minlimits_theta_l le theta le theta_u frac12Y-m(Xtheta)_2^2","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The objective function is defined as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"nls = NLS_ForwardDiff_From_Model2Fit(recalibration_model,X,Y)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"The constraints are: ","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"0 le h_i : we want positive peak heights.\nmu^texttrue_i = mu_i : peak centers are constants. If this was not the case, the recalibration mapping would be meaning less.\nepsilon le sigma_i : the Gaussian peak shape factor must be positives.\n05 le hattheta_i le 15 : we keep recalibration transform in a neighbourhood of the identity transform.","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"This can be encoded as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"ε = eps(Float64)\n#                       h1 μ1   σ1,  h2  μ2   σ2   h3   μ3   σ3  θA   θB\nlower_bound = Float64[   0, 5,   ε,   0, 10,   ε,   0,  20,   ε, 0.5, 0.5]\nupper_bound = Float64[ Inf, 5, Inf, Inf, 10, Inf, Inf, 20, Inf, 1.5, 1.5]\n\nbc = NLS_Solver.BoundConstraints(lower_bound,upper_bound);","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We must now choose a bound constrained solver. We use the modified version of the Levenberg-Marquardt method with its default parameters:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"conf = NLS_Solver.LevenbergMarquardt_BC_Conf()","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can now solve the problem:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"result = NLS_Solver.solve(nls,θ_init_recalibration_model,bc,conf)","category":"page"},{"location":"recalibration/#Fit-result","page":"Peak fitting and recalibration","title":"Fit result","text":"","category":"section"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"First, check that the method converged:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"NLS_Solver.converged(result)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"and plot the result:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"θ_fit_recalibration_model = NLS_Solver.solution(result)\nY_fit_recalibration_model = eval_y(recalibration_model,X,θ_fit_recalibration_model)\nplot!(X,Y_fit_recalibration_model, linewidth = 3, label = \"fitted model\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We see a good agreement between the data and the fitted model, however the plotted hatX is still the uncalibrated axe. What we want is the transformed one: X=f_hattheta(hatX). This calibrated X can computed as follows:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"X_recalibrated = eval_calibrated_x(recalibration_model,X,θ_fit_recalibration_model)\nplot(X_true, seriestype = :scatter, markershape = :xcross, label = \"true X\")\nplot!(X, seriestype = :scatter, label = \"miscalibrated X\")\nplot!(X_recalibrated, seriestype = :scatter, markershape = :cross, label = \"recalibrated X\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We see that we retrieved the right calibration:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"initial miss calibration","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"norm(X_true - X, Inf)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"recalibrated X","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"norm(X_true - X_recalibrated, Inf)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"We can also retrieve the initial model, the one that needs the calibrated X, with its parameters (the extra hattheta are removed). This model is our initial sum of the 3 Gaussian peaks:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"model == get_calibrated_model(recalibration_model)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"θ_fitted = get_calibrated_model_θ(recalibration_model,θ_fit_recalibration_model)","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"With this, we can plot the model using the calibrated domain:","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"Y_fitted = eval_y(model, X_recalibrated, θ_fitted)\nplot(X_recalibrated,Y, seriestype = :scatter, label = \"raw data\")\nplot!(X_recalibrated,Y_fitted, linewidth = 3, label = \"fitted model (after recalibration)\")","category":"page"},{"location":"recalibration/","page":"Peak fitting and recalibration","title":"Peak fitting and recalibration","text":"we clearly see now that, after recalibration, the Gaussian peak centers 5, 10, 20 are consistent with the plot.","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of this package is to provide an easy to use framework to fit models like spectrum peaks.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"simple_fit.md\",\n    \"recalibration.md\",\n    \"constrained_parameters.md\",\n]\nDepth = 3","category":"page"},{"location":"","page":"Home","title":"Home","text":"TODO: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tag & visit method\nlinear parameters\nstacked models","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Doc","page":"API","title":"Doc","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [NLS_Fit]","category":"page"},{"location":"API/#NLS_Fit.Abstract_Map","page":"API","title":"NLS_Fit.Abstract_Map","text":"Map base type. \n\nThis type is an abstraction of a fX  Y=f(X).\n\nSuch transformations can be used in various contexts:\n\ncalibration task: we have a reference hatX to a calibrated X\nparameter transformation: we map a parameter vector hatθ to a new one θ.\n\nInterface\n\nparameter_size\neval_map \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Abstract_Model2Fit","page":"API","title":"NLS_Fit.Abstract_Model2Fit","text":"Abstract type, base of all model to fit.\n\nInterface\n\nparameter_size \naccumulate_y! \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Gaussian_Peak","page":"API","title":"NLS_Fit.Gaussian_Peak","text":"Gaussian peak\n\np(x θ = hμσ) = h e^-frac12 left(fracx-μσ right)^2\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Map_Affine","page":"API","title":"NLS_Fit.Map_Affine","text":"Map_Affine(X_hat_A => X_A, X_hat_B => X_B)\n\nMap_Affine(X_hat_A, X_hat_B)\n\nThe second constructor is a shortcut for\n\nMap_Affine(X_hat_A => X_hat_A, X_hat_B => X_hat_B)\n\nDefines an affine transformation:\n\nX(hatX) = L_A(hatX) X_A θ_A +  L_B(hatX) X_B θ_B\n\nwhere L_A and L_B are the Lagrange basis.\n\nIn peculiar, for (θ_Aθ_B) = (11) we have an affine map such that X(hatX_A) = X_A and X(hatX_B) = X_B.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Map_Affine_Monotonic","page":"API","title":"NLS_Fit.Map_Affine_Monotonic","text":"Map_Affine_Monotonic(X_hat_A => X_A, X_hat_B => X_B)\n\nMap_Affine_Monotonic(X_hat_A, X_hat_B)\n\nThe second constructor is a shortcut for\n\nMap_Affine_Monotonic(X_hat_A => X_hat_A, X_hat_B => X_hat_B)\n\nSame as Map_Affine but uses another parametrization that allows to insure monotonic map using simple bound constraints.\n\nThe Map_Affine map is defined as follows:\n\nX(hatX) = L_A(hatX) X_A θ_A +  L_B(hatX) X_B θ_B\n\nWith this parametrization you have to add the X_B θ_B  X_A θ_A to insure that the map is increasing.\n\nOn the other hand, with the Map_Affine_Monotonic parametrization:\n\nX(hatX) = L_A(hatX) X_A θ_A +  L_B(hatX) ( (X_B-X_A) θ_B + X_A θ_A )\n\nwhere \n\nfracdXdhatX = fracX_B-X_AhatX_B-hatX_A θ_B\n\na simply bound constraint θ_B  0 is sufficient to preserve the increasing or decreasing character. This preserved slope is given by the sign of fracX_B-X_AhatX_B-hatX_A which is constant once the structure has been initialized.\n\nIn peculiar, for (θ_Aθ_B) = (11) we have an affine map such that X(hatX_A) = X_A and X(hatX_B) = X_B. Whereas for (θ_Aθ_B) = (10) we have a constant one.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Map_Translate","page":"API","title":"NLS_Fit.Map_Translate","text":"Map_Translate(;scale = 1)\n\nDefines a translate transformation:\n\nX(hatX) = hatX + scale (θ - 1)\n\nIn peculiar, for (θ) = (1) the transformation is identity.  This is due to the presence of the θ- 1 factor. This factor is introduced to stay consistent with other transformations where we try to have identity transform for parameter vector of ones.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Empty","page":"API","title":"NLS_Fit.Model2Fit_Empty","text":"An empty model without parameters. This is useful to initialize summation:\n\nmodel = Model2Fit_Empty()\n\nfor i in 1:n\n    model = model + GaussianPeak()\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Mapped_Parameters","page":"API","title":"NLS_Fit.Model2Fit_Mapped_Parameters","text":"Create a new model, where some parameters are computed using a Abstract_Map.\n\nTODO: not clear how to use it: certainly need a refactoring...\n\nAlso see\n\nModel2Fit_Shared_Parameters \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Recalibration","page":"API","title":"NLS_Fit.Model2Fit_Recalibration","text":"Create a calibrable model\n\nConstructors\n\ncalibrable_model = Model2Fit_Recalibration(model_to_calibrate, calibration_map)\n\nwhere model_to_calibrate is an Abstract_Model2Fit and calibration_map is an Abstract_Map\n\nExplanation\n\nThe call\n\neval_y(calibrable_model,X_hat,[θ, θ_map])\n\nis equivalent to \n\neval_y(model_to_calibrate,eval_calibrated_x(X_hat, θ_map), [θ])\n\nAlso see\n\nget_calibration_map \nget_calibration_map_θ \nget_calibrated_model \nget_calibrated_model_θ \neval_calibrated_x \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Shared_Parameters","page":"API","title":"NLS_Fit.Model2Fit_Shared_Parameters","text":"Share a set of parameters\n\nExample\n\nLet's assume that we have an initial model model with θ as parameter vector.  If we want θ1, θ3, θ5 to share a same value θshared then:\n\nindices_to_share = [1,3,5]\n        \nmodel_with_shared_params = Model2Fit_Shared_Parameters(model, indices_to_share)\n\nDo not forget to udpate parameter vector θ, this can be done as follows:\n\ndeleteat!(θ, indices_to_share)\npush!(θ, θshared)\n\nAlso see\n\nModel2Fit_Mapped_Parameters \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_Stacked","page":"API","title":"NLS_Fit.Model2Fit_Stacked","text":"Define a composite model, where each submodel is responsible of a given ROI\n\n| (1)        | (2)       | ...  |––––––|–––––-| ... | models[1]  | model[2]  | ...\n\nDomain (1) range is defined as 1:ROIsizes[1] Domain (2) range is defined as (ROIsizes[1]+1):ROI_sizes[2] etc...\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.Model2Fit_TaggedModel","page":"API","title":"NLS_Fit.Model2Fit_TaggedModel","text":"Model2Fit_TaggedModel(model,data)\n\nTag model and embed data\n\nExtra method\n\nget_tagged_data \nget_tagged_model \nget_tagged_data_type \n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.NLS_ForwardDiff_From_Model2Fit","page":"API","title":"NLS_Fit.NLS_ForwardDiff_From_Model2Fit","text":"A wrapper that allows to use the NLS_Solver.jl package to solve the nonlinear least squares problem associated to a model plus its (X,Y) data.\n\nYou must construct an instance of nls problem as follows:\n\nNLS_ForwardDiff_From_Model2Fit(fit_model::MODEL2FIT_TYPE,\n                               X::X_TYPE,\n                               Y::Y_TYPE)\n\nYou can then use the NLS_Solver package as usual, but with prefixed NLS_Solver.\n\nnls = NLS_ForwardDiff_From_Model2Fit(model,X,Y)\nconf = NLS_Solver.LevenbergMarquardt_Conf()\nresult = NLS_Solver.solve(nls,θ_init,conf)\n\nCAVEAT:\n\nPlease note that you should not explicitly\n\nusing NLS_Solver\n\nas this package is reexported from NLS_Fit.  Doing so avoids potential version compatibility problems.\n\n\n\n\n\n","category":"type"},{"location":"API/#NLS_Fit.accumulate_y!-Tuple{NLS_Fit.Abstract_Model2Fit, AbstractVector, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.accumulate_y!","text":"accumulate_y!(::Abstract_Model2Fit,Y::AbstractVector,X::AbstractVector,θ::AbstractVector)::AbstractVector\n\nAccumulate model contribution into vector Y.\n\nAlso see : \n\nAbstract_Model2Fit\neval_y \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.eval_calibrated_x-Tuple{Model2Fit_Recalibration, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.eval_calibrated_x","text":"eval_calibrated_x(m::Model2Fit_Recalibration,X_hat::AbstractVector,θ::AbstractVector) -> AbstractVector\n\nCompute the calibrated X from the reference domain hatX for the given transformation parameters θ.\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.eval_map-Tuple{NLS_Fit.Abstract_Map, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.eval_map","text":"eval_map(m::Abstract_Map,X_hat::AbstractVector,θ::AbstractVector) -> X::AbstractVector\n\nCompute X=X(hatX).\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.eval_y-Tuple{NLS_Fit.Abstract_Model2Fit, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.eval_y","text":"eval_y(m::Abstract_Model2Fit,X::AbstractVector,θ::AbstractVector)::AbstractVector\n\nA convenience function that call accumulate_y! using a zero initialized Y vector. This returned vector contains model values.\n\nAlso see : \n\nAbstract_Model2Fit\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibrated_model-Tuple{Model2Fit_Recalibration}","page":"API","title":"NLS_Fit.get_calibrated_model","text":"get_calibrated_model(model::Model2Fit_Recalibration)::Abstract_Model2Fit\n\nRetrieve the underlying model to calibrate\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibrated_model_θ-Tuple{Model2Fit_Recalibration, AbstractVector}","page":"API","title":"NLS_Fit.get_calibrated_model_θ","text":"get_calibrated_model_θ(model::Model2Fit_Recalibration,\n                       θ::AbstractVector)::AbstractVector\n\nRetrieve the parameter vector of the underlying model to calibrate\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibration_map-Tuple{Model2Fit_Recalibration}","page":"API","title":"NLS_Fit.get_calibration_map","text":"get_calibration_map(model::Model2Fit_Recalibration)::Abstract_Map\n\nRetrieve the calibration map, of type Abstract_Map.\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_calibration_map_θ-Tuple{Model2Fit_Recalibration, AbstractVector}","page":"API","title":"NLS_Fit.get_calibration_map_θ","text":"get_calibration_map_θ(model::Model2Fit_Recalibration,\n                      θ::AbstractVector)::AbstractVector\n\nRetrieve the calibration map parameters\n\nSee: Model2Fit_Recalibration \n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model-Tuple{Model2Fit_Mapped_Parameters}","page":"API","title":"NLS_Fit.get_model","text":"get_model(mp::Model2Fit_Mapped_Parameters) -> Absatrct_Model2Fit\n\nGet back the wrapped model\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model-Tuple{Model2Fit_Shared_Parameters}","page":"API","title":"NLS_Fit.get_model","text":"get_model(mp::Model2Fit_Shared_Parameters) -> Absatrct_Model2Fit\n\nGet back the wrapped model\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model_θ-Tuple{Model2Fit_Mapped_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_model_θ","text":"get_model_θ(mp::Model2Fit_Mapped_Parameters,θ::AbstractVector) -> θ::AbstractVector\n\nRetrieve the parameter vector θ associated to the wrapped model get_model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_model_θ-Tuple{Model2Fit_Shared_Parameters, AbstractVector}","page":"API","title":"NLS_Fit.get_model_θ","text":"get_model_θ(mp::Model2Fit_Shared_Parameters,θ::AbstractVector) -> θ::AbstractVector\n\nRetrieve the parameter vector θ associated to the wrapped model get_model.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_data-Tuple{Model2Fit_TaggedModel}","page":"API","title":"NLS_Fit.get_tagged_data","text":"get_tagged_data(m::Model2Fit_TaggedModel{MODEL,DATA)::DATA\n\nReturn embedded data\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_data_type-Tuple{NLS_Fit.Abstract_Model2Fit}","page":"API","title":"NLS_Fit.get_tagged_data_type","text":"get_tagged_data_type(m::Abstract_Model2Fit)::DataType\n\nReturn embedded data type, or Nothing if m is not a Model2Fit_TaggedModel.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_model-Tuple{Model2Fit_TaggedModel}","page":"API","title":"NLS_Fit.get_tagged_model","text":"get_tagged_model(m::Model2Fit_TaggedModel{MODEL,DATA)::DATA\n\nReturn tagged model\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.get_tagged_model_type-Tuple{NLS_Fit.Abstract_Model2Fit}","page":"API","title":"NLS_Fit.get_tagged_model_type","text":"get_tagged_model_type(m::Abstract_Model2Fit)::DataType\n\nReturn wrapped model type, or Nothing if m is not a Model2Fit_TaggedModel.\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.insert_some_elements","page":"API","title":"NLS_Fit.insert_some_elements","text":"insert_some_elements(X::AbstractVector{T},\n                     indices::AbstractVector{Int},\n                     elements::AbstractVector) -> AbstractVector{T}\n\nInsert elements in X at positions indices.\n\nNote: indices must be strictly ordered.\n\nExample: this functions does a work inverse to the deleteat!\n\njulia> X = Any[1:10;]\n10-element Vector{Any}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\njulia> indices = Int[2, 3, 5, 6, 9, 10];\n\njulia> elements = Float64[2, 3, 5, 6, 9, 10];\n\njulia> deleteat!(X, indices)\n4-element Vector{Any}:\n 1\n 4\n 7\n 8\n\njulia> insert_some_elements(X,indices,elements)\n10-element Vector{Any}:\n  1\n  2.0\n  3.0\n  4\n  5.0\n  6.0\n  7\n  8\n  9.0\n 10.0\n\n\n\n\n\n\n","category":"function"},{"location":"API/#NLS_Fit.parameter_size-Tuple{NLS_Fit.Abstract_Map}","page":"API","title":"NLS_Fit.parameter_size","text":"parameter_size(::Abstract_Map) -> Int\n\nReturn θ parameter vector length\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.parameter_size-Tuple{NLS_Fit.Abstract_Model2Fit}","page":"API","title":"NLS_Fit.parameter_size","text":"parameter_size(::Abstract_Model2Fit)::Int\n\nReturn length of the expected parameter vector θ\n\nAlso see : \n\nAbstract_Model2Fit\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.solve_linear_parameters-Tuple{NLS_Fit.Abstract_Model2Fit, AbstractVector, AbstractVector, AbstractVector, AbstractVector{Int64}}","page":"API","title":"NLS_Fit.solve_linear_parameters","text":"Find optimal linear parameters\n\n\n\n\n\n","category":"method"},{"location":"API/#NLS_Fit.visit-Tuple{Function, NLS_Fit.Abstract_Model2Fit, AbstractVector, AbstractVector, AbstractVector}","page":"API","title":"NLS_Fit.visit","text":"visit(mp::Abstract_Model2Fit,X::AbstractVector,θp::AbstractVector,action::Function) -> nothing\n\nRecursively visit models using a depth-first-order.\n\nFor each visited model, performian action which is a function of type\n\nvisit_default_action(m::Abstract_Model2Fit,x::AbstractVector,θ::AbstractVector)  -> Bool\n\nIf the function returns false the depth-first-search is stopped.\n\nImplementation details\n\nThe visit functionality requires these methods to be defined for each visited model:\n\nvisitsubmodelsize(model)\nvisitgetsubmodel(model,submodel_idx)\nvisitgetY(model,submodel_idx,Y,X,θ)\nvisitgetX(model,submodel_idx,Y,X,θ)\nvisitgetθ(model,submodel_idx,Y,X,θ)\n\nThere is no need to export these methods.\n\nThese functions never modifies Y components, in some cases like Model2Fit_Stacked, visit_get_Y returns a view.\n\n\n\n\n\n","category":"method"}]
}
